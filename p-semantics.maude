in "p-syntax.maude"

mod P-SEMANTICS is including P-SYNTAX .
  --- State
  -----------------

  --- The state consists of a AC soup of attributes.

  sorts Attribute Attributes .
  subsort Attribute < Attributes .
  op .Attribute : -> Attributes .
  op __ : Attributes Attributes -> Attributes [prec 65 assoc comm id: .Attribute] .

  --- The init constructs an initial configuration from a program
  --- with the ( pgm: cell storing the initial program.

  op (( pgm: _ )) : Stmt -> Attribute [prec 64 format(n d ++i -- d)] .

  op init : Stmt -> Attributes .
  -----------------------
  eq init(Ss)
   = ( pgm: Ss )
     ( machines:  .MachineSchemas )
   .

  --- Machine Schemas
  ----------------------

  --- Machine statements are schema for initializing new machines.
  --- For each machine statement, we load them into the ( machine: ) record.

  sort MachineSchema .
  sort MachineAttributes .
  op .MAttrs : -> MachineAttributes .
  op _ , _ : MachineAttributes MachineAttributes -> MachineAttributes [prec 65 assoc comm id: .MAttrs format(d ni d d)] .
  var MAttrs : MachineAttributes .
  var MAttrs* : [MachineAttributes] .
  op (( start:     _ )) : Id          -> MachineAttributes  .
  op (( states:    _ )) : States      -> MachineAttributes [format(d d ++ni --ni n)] .
  op (( initState: _ )) : VariableMap -> MachineAttributes [format(d d ++ni --ni d)] .

  op (( machine: _ , _ )) : Id MachineAttributes -> MachineSchema [format(d d d ++ni d d --ni)] .
  op noid : -> [Id] .

  --- States
  ----------
  sort State .
  sort StateAttributes .
  op .SAttrs : -> StateAttributes .
  op _ , _ : StateAttributes StateAttributes -> StateAttributes [prec 65 assoc comm id: .SAttrs] .
  var SAttrs : StateAttributes .
  op (( entry: _ )) : Block -> StateAttributes .
  op (( actions: _ )) : Actions -> StateAttributes [format(d d ++ni --ni n)] .

  op (( state: _, _ )) : Id StateAttributes -> State [format(d d d ++ni d d --ni) ] .

  sort States .
  subsort State < States .
  op .States : -> States .
  op _ _ : States States -> States [assoc comm id: .States format(d ni d)] .

  --- Actions
  -----------
  sort Action Actions .
  subsort Action < Actions .

  op .Actions : -> Actions .
  op _ _ : Actions Actions -> Actions [prec 62 assoc comm id: .Actions] .
  var Actns : Actions .

  --- Arguments Id Code
  op (( action: _ , _ )) : Id Stmt -> Action .

  sort MachineSchemas .
  subsort MachineSchema < MachineSchemas .
  op .MachineSchemas : -> MachineSchemas .
  op _ ;; _ : MachineSchemas MachineSchemas -> MachineSchemas [assoc comm id: .MachineSchemas] .

  var Schema : MachineSchema .
  var Schema* : [MachineSchema] .
  var Schemas : MachineSchemas .

  --------------------------------------------------------------------------------

  op (( machines: _ )) : MachineSchemas -> Attribute [prec 64 format (n d ++ni d d)] .

  rl ( pgm: ( machine Id ; B ) Ss )
     (machines:  Schemas )
  => ( pgm: Ss )
     (machines:  statementToMachineSchema(machine Id ; B) ;; Schemas )
   .

  op (( main: _ )) : Id -> Attribute [prec 64] .
  rl ( pgm: ( main machine Id ; B ) Ss )
  => ( pgm: ( machine Id ; B ) Ss )
     ( main:  Id  )
   .

 --- For now, we we do not process "sends" clauses, so we ignore them.
  eq machine Id sends Exps ; B
   = machine Id ; B
   .

 --- The schema for the main machine is used to initialize the machine soup.
  op (( counter: _ )) : Nat -> Attribute [prec 64] .
  rl ( pgm: .Stmt )
     ( main:  MId  )
  => ( counter: 1 )
     ( instances: (new: MId, 0, .Exps) )
   .

  op statementToMachineSchema : MachineStmt                 -> MachineSchema .
  op statementToMachineSchema : Stmt        [MachineSchema] -> MachineSchema .
  -------------------------------------------
  eq statementToMachineSchema(machine Id ; B)
   = statementToMachineSchema(B, (machine: Id, (start: noid), (states: .States), (initState: .VariableMap))) .

  eq statementToMachineSchema({ Ss }, Schema*) = statementToMachineSchema(Ss, Schema*) .
  eq statementToMachineSchema(var X : T ; Ss, (machine: Id, (initState: Rho          ), MAttrs*))
   = statementToMachineSchema(Ss,             (machine: Id, (initState: (X |-> 0 Rho)), MAttrs*))
   .

  eq statementToMachineSchema((start state SId B) Ss, (machine: MId, (start: noid), MAttrs))
   = statementToMachineSchema((      state SId B) Ss, (machine: MId, (start: SId),  MAttrs))
   .

  eq statementToMachineSchema((state SId B) Ss, (machine: MId, (states:                                                                   States), MAttrs*))
   = statementToMachineSchema(              Ss, (machine: MId, (states: (statementToState(B, (state: SId, (actions: .Actions), .SAttrs))) States), MAttrs*))
   .

  eq statementToState({ Ss }, State) = statementToState(Ss,     State) .

  eq statementToState(entry B Ss, (state: SId,             SAttrs))
   = statementToState(Ss        , (state: SId, (entry: B), SAttrs))
   .

  eq statementToState(on EId do B Ss, (state: SId, (actions:                  Actns), SAttrs))
   = statementToState(Ss,             (state: SId, (actions: (action: EId, B) Actns), SAttrs))
   .

  eq statementToState(.Stmt, State) = State .

  eq statementToMachineSchema(.Stmt, Schema) = Schema .

  --- Arguments: MachineId StateId Statements
  op statementToState(_ , _) : Stmt State -> State .

 --- Machine Instances
 ---------------------

  sort MachineInstance MachineInstances .
  subsort MachineInstance < MachineInstances .
  op .MachineInstances : -> MachineInstances .
  op _ _ : MachineInstances MachineInstances -> MachineInstances [prec 65 assoc comm id: .MachineInstances] .

  sort InstanceAttributes .
  op .IAttrs : -> InstanceAttributes .
  op _ , _ : InstanceAttributes InstanceAttributes -> InstanceAttributes [prec 65 assoc comm id: .IAttrs] .
  var IAttrs IAttrs1  IAttrs2 : InstanceAttributes .
  op ((code:   _ )) : Stmt        -> InstanceAttributes .
  op ((variables:  _ )) : VariableMap -> InstanceAttributes .
  op ((state:  _ )) : Id -> InstanceAttributes .
  op ((mid:  _ )) : Id -> InstanceAttributes .

  op ((buffer:  _ )) : Messages -> InstanceAttributes .
  sort Messages .
  op .Messages : -> Messages .
  op _ , _ : Messages Messages -> Messages [assoc comm id: .Messages] .
  op { _ } : Exps -> Messages  .


 --- arguments: Reference | Code | StateCell
  op (( instance: _ , _ )) : Int InstanceAttributes -> MachineInstance [prec 63] .

  var Machine  : MachineInstance .
  var Machines : MachineInstances .

  op (( instances: _ )) : MachineInstances -> Attribute [prec 64 format (ncu o++in o n--icu p)] .

 --- Expressions
 ---------------

  op eval : Exps VariableMap -> [Int] .
 --------------------------------------
  eq eval(V,            Rho) = V .
  eq eval(Id, (Id |-> V) Rho) = V .

 --- Statements
 --------------

 --- Blocks
  eq (instance: N , (code: { Ss }) , IAttrs)
   = (instance: N , (code:   Ss  ) , IAttrs)
   .

 --- Assignment
  eq (instance: M , (code: X = V ; Ss), (variables: X |-> V2 Rho), IAttrs )
   = (instance: M , (code:         Ss), (variables: X |-> V  Rho), IAttrs )
   .

 --- goto
  rl (instance: M , (code: goto Id ; Ss), (variables: Rho), IAttrs)
  => (instance: M , enterState(Id),       (variables: Rho), IAttrs)
   .

 --- new
  rl ( counter: N )
     (instances: ( instance: M , (code: X = new MId(Exps); Ss), IAttrs) Machines )
  => ( counter: N +Int 1 )
     (instances: ( instance: M , (code: X = N ;            Ss), IAttrs) Machines
                    (new: MId, N, Exps)
     )
   .

 --- send
 ceq ( instance: M , (code: send Exp,Exps ; Ss), (variables: Rho), IAttrs1)
   = ( instance: M , (code: send eval(Exp, Rho),Exps ; Ss), (variables: Rho), IAttrs1)
  if notBool(Exp :: Nat)
   .

  rl ( instance: M , (code: send N,Exps ; Ss), IAttrs1)
     ( instance: N , (buffer: Messages), IAttrs2)
  => ( instance: M , (code: Ss), IAttrs1)
     ( instance: N , (buffer: ({Exps}, Messages)), IAttrs2)
   .

 --- arguments: MachineId, Identifier, Arguments
  op ((new: _, _, _)) : Id Nat Exps -> MachineInstance .
  eq (instances: (new: MId, N, Exps) Machines )
     (machines:  (machine: MId, (start: StartId), (initState: Rho), MAttrs) ;; Schemas )
   = (machines:  (machine: MId, (start: StartId), (initState: Rho), MAttrs) ;; Schemas )
     (instances: (instance: N, (mid: MId)
                             , enterState(StartId)
                             , (state: noid)
                             , (variables: Rho)
                             , (buffer: .Messages)
                 )
                 Machines
     )
   .

  op enterState : Id -> InstanceAttributes .
  eq (instances: (instance: M , (mid: MId), (state: Id*), enterState(SId), IAttrs) Machines)
     (machines:  (machine: MId, (states: (state: SId, SAttrs) States), MAttrs) ;; Schemas )
   = (instances: (instance: M , (mid: MId), (state: SId), enterState.code(SId), IAttrs) Machines)
     (machines:  (machine: MId, (states: (state: SId, SAttrs) States), MAttrs) ;; Schemas )
   .

  op enterState.code : Id -> InstanceAttributes .
  eq (instances: (instance: M , (mid: MId), enterState.code(SId), IAttrs) Machines)
     (machines:  (machine: MId, (states: (state: SId, (entry: Ss), SAttrs) States), MAttrs) ;; Schemas )
   = (instances: (instance: M , (mid: MId), (code: Ss), IAttrs) Machines)
     (machines:  (machine: MId, (states: (state: SId, (entry: Ss), SAttrs) States), MAttrs) ;; Schemas )
   .
  eq (instances: (instance: M , (mid: MId), enterState.code(SId), IAttrs) Machines)
     (machines:  (machine: MId, (states: (state: SId, SAttrs) States), MAttrs) ;; Schemas )
   = (instances: (instance: M , (mid: MId), (code: .Stmt), IAttrs) Machines)
     (machines:  (machine: MId, (states: (state: SId, SAttrs) States), MAttrs) ;; Schemas )
     [owise]
   .

  --- Other infrastructure
  ------------------------

  --- Maps
  sort VariableMap .
  op .VariableMap : -> VariableMap .
  op _|->_ : Id Exp -> VariableMap [prec 60 format (n++i r o --i) ] .
  op _ _ : VariableMap VariableMap -> VariableMap [prec 62 assoc comm id: .VariableMap] .

  var X Y Id MId SId EId : Id .
  var N M : Nat .
  var V V1 V2 : Int .
  var Id* : [Id] .
  var StartId* : [Id] .
  var StartId  :  Id .
  var T : Type .
  var B : Block .
  var Ss S1s S2s : Stmt .
  var Rho : VariableMap .
  var C : Attributes .
  var Exps : Exps .
  var Exp : Exp .
  var State : State .
  var States : States .
  var Messages : Messages .

endm

