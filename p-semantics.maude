in "p-syntax.maude"

mod P-SEMANTICS is including P-SYNTAX .

  --- Configuration
  -----------------

  --- The configuration consists of a AC soup of cells.

  sorts Cell Cfg .
  subsort Cell < Cfg .
  op .Cell : -> Cfg .
  op __ : Cfg Cfg -> Cfg [prec 65 assoc comm id: .Cell] .

  --- The init constructs an initial configuration from a program
  --- with the <k> cell storing the initial program.

  op <k>_</k> : Stmt -> Cell [prec 64 format (ncu o++i n--icu o)] .

  op init : Stmt -> Cfg .
  -----------------------
  eq init(Ss)
   = <k> Ss </k>
     <machines> .MachineSchemas </machines>
   .

  --- Machine Statements
  ----------------------

  --- Machine statements are schema for initializing new machines.
  --- For each machine statement, we load them into the <machine> cell.

  sort MachineSchema .
  op (( machine: _ , start: _ , states: _ , initState: _ )) : Id Id States VariableMap -> MachineSchema .
  op noid : -> [Id] .

  sort State .
  op (( state: _, entry: _ )) : Id Block -> State .

  sort States .
  subsort State < States .
  op .States : -> States .
  op _ _ : States States -> States [assoc comm id: .States] .

  sort MachineSchemas .
  subsort MachineSchema < MachineSchemas .
  op .MachineSchemas : -> MachineSchemas .
  op _ ;; _ : MachineSchemas MachineSchemas -> MachineSchemas [assoc comm id: .MachineSchemas] .

  --------------------------------------------------------------------------------

  op <machines>_</machines> : MachineSchemas -> Cell [prec 64 format (ngu o++i n--igu o)] .

  rl <k> ( machine I ; B ) Ss </k>
     <machines> Schemas </machines>
  => <k> Ss </k>
     <machines> statementToMachineSchema(machine I ; B) ;; Schemas </machines>
   .

  op <main>_</main> : Id -> Cell [prec 64] .
  rl <k> ( main machine I ; B ) Ss </k>
  => <k> ( machine I ; B ) Ss </k>
     <main> I </main>
   .

 --- For now, we we do not process "sends" clauses, so we ignore them.
  eq machine I sends Exps ; B
   = machine I ; B
   .

 --- The schema for the main machine is used to initialize the machine soup.
  op <counter: _ > : Nat -> Cell [prec 64] .
  rl <k> .Stmt </k>
     <main> MId </main>
  => <counter: 1 >
     <soup> (new: MId, 0, .Exps) </soup>
   .

  op statementToMachineSchema : MachineStmt                 -> MachineSchema .
  op statementToMachineSchema : Stmt        [MachineSchema] -> MachineSchema .
  -------------------------------------------
  eq statementToMachineSchema(machine I ; B)
   = statementToMachineSchema(B, (machine: I, start: noid, states: .States, initState: .VariableMap)) .

  eq statementToMachineSchema({ Ss }, Schema*) = statementToMachineSchema(Ss, Schema*) .
  eq statementToMachineSchema(var X : T ; Ss, (machine: I, start: Start:[Id], states: States, initState: Rho))
   = statementToMachineSchema(Ss, (machine: I, start: Start:[Id], states: States, initState: (X |-> 0 Rho)))
   .

  eq statementToMachineSchema((start state SId B) Ss, (machine: MId, start: noid, states: States, initState: Rho))
   = statementToMachineSchema((      state SId B) Ss, (machine: MId, start: SId,  states: States, initState: Rho))
   .

  eq statementToMachineSchema((state SId { entry B }) Ss, (machine: MId, start: StartId*, states: States, initState: Rho))
   = statementToMachineSchema(                        Ss, (machine: MId, start: StartId*, states: ((state: SId, entry: B) States), initState: Rho))
   .

  eq statementToMachineSchema(.Stmt, Schema) = Schema .

  --- Statements
  --------------

  eq < N | { Ss } | Rho > = < N | Ss | Rho > .

 --- Assignment
  eq < M | X = V ; Ss | (X |-> V2 Rho) >
   = < M |         Ss | (X |-> V  Rho) >
   .

 --- new
  eq <soup> < M | X = new MId(Exps); Ss | Rho >                             C </soup> <counter: N >
   = <soup> < M | X = N ;            Ss | Rho > (new: MId, N +Int 1, Exps)  C </soup> <counter: N +Int 2 >
   .

 --- MachineId, Identifier, Arguments
  op ((new: _, _, _)) : Id Nat Exps -> Cell .
  eq <soup> (new: MId, N, Exps) C </soup>
     <machines> (machine: MId, start: StartId, states: ((state: StartId, entry: Ss) States), initState: Rho) ;; Schemas </machines>
   = <soup> < N | Ss | Rho > C </soup>
     <machines> (machine: MId, start: StartId, states: ((state: StartId, entry: Ss) States), initState: Rho) ;; Schemas </machines>
   .

  --- Other infrastructure
  ------------------------

  --- Maps
  sort VariableMap .
  op .VariableMap : -> VariableMap .
  op _|->_ : Id Exp -> VariableMap [prec 60 format (n++i r o --i) ] .
  op _ _ : VariableMap VariableMap -> VariableMap [prec 62 assoc comm id: .VariableMap] .

  --- "Reference" | "Executing Code" | "State"
  op <_|_|_> : Int Stmt VariableMap -> Cell [prec 63 format (o ni++ --ino n++i --inr on++i --in o)] .
  op <soup>_</soup> : Cfg -> Cell [prec 64 format (ncu o++in n--icu p)] .

  var I X Y MId SId : Id .
  var N M : Nat .
  var V V1 V2 : Int .
  var StartId* : [Id] .
  var StartId  :  Id .
  var T : Type .
  var B : Block .
  var Ss S1s S2s : Stmt .
  var Rho : VariableMap .
  var C : Cfg .
  var Exps : Exps .
  var States : States .
  var Schema : MachineSchema .
  var Schema* : [MachineSchema] .
  var Schemas : MachineSchemas .

endm

