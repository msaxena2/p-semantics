in "p-syntax.maude"

mod P-SEMANTICS is including P-SYNTAX .

  --- State
  -----------------

  --- The state consists of a AC soup of attributes.

  sorts Attribute Attributes .
  subsort Attribute < Attributes .
  op .Attribute : -> Attributes .
  op __ : Attributes Attributes -> Attributes [prec 65 assoc comm id: .Attribute] .

  --- The init constructs an initial configuration from a program
  --- with the ( pgm: cell storing the initial program.

  op (( pgm: _ )) : Stmt -> Attribute [prec 64 format (ncu o++i o n--icu o)] .

  op init : Stmt -> Attributes .
  -----------------------
  eq init(Ss)
   = ( pgm: Ss )
     ( machines:  .MachineSchemas )
   .

  --- Machine Statements
  ----------------------

  --- Machine statements are schema for initializing new machines.
  --- For each machine statement, we load them into the ( machine: ) record.

  sort MachineSchema .
  op (( machine: _ , start: _ , states: _ , initState: _ )) : Id Id States VariableMap -> MachineSchema .
  op noid : -> [Id] .

  sort State .
  op (( state: _, entry: _ )) : Id Block -> State .

  sort States .
  subsort State < States .
  op .States : -> States .
  op _ _ : States States -> States [assoc comm id: .States] .

  sort MachineSchemas .
  subsort MachineSchema < MachineSchemas .
  op .MachineSchemas : -> MachineSchemas .
  op _ ;; _ : MachineSchemas MachineSchemas -> MachineSchemas [assoc comm id: .MachineSchemas] .

  var Schema : MachineSchema .
  var Schema* : [MachineSchema] .
  var Schemas : MachineSchemas .

  --------------------------------------------------------------------------------

  op (( machines: _ )) : MachineSchemas -> Attribute [prec 64 format (ngu o++i o n--igu o)] .

  rl ( pgm: ( machine Id ; B ) Ss )
     (machines:  Schemas )
  => ( pgm: Ss )
     (machines:  statementToMachineSchema(machine Id ; B) ;; Schemas )
   .

  op (( main: _ )) : Id -> Attribute [prec 64] .
  rl ( pgm: ( main machine Id ; B ) Ss )
  => ( pgm: ( machine Id ; B ) Ss )
     ( main:  Id  )
   .

 --- For now, we we do not process "sends" clauses, so we ignore them.
  eq machine Id sends Exps ; B
   = machine Id ; B
   .

 --- The schema for the main machine is used to initialize the machine soup.
  op (( counter: _ )) : Nat -> Attribute [prec 64] .
  rl ( pgm: .Stmt )
     ( main:  MId  )
  => ( counter: 1 )
     ( instances: (new: MId, 0, .Exps) )
   .

  op statementToMachineSchema : MachineStmt                 -> MachineSchema .
  op statementToMachineSchema : Stmt        [MachineSchema] -> MachineSchema .
  -------------------------------------------
  eq statementToMachineSchema(machine Id ; B)
   = statementToMachineSchema(B, (machine: Id, start: noid, states: .States, initState: .VariableMap)) .

  eq statementToMachineSchema({ Ss }, Schema*) = statementToMachineSchema(Ss, Schema*) .
  eq statementToMachineSchema(var X : T ; Ss, (machine: Id, start: Start:[Id], states: States, initState: Rho))
   = statementToMachineSchema(Ss, (machine: Id, start: Start:[Id], states: States, initState: (X |-> 0 Rho)))
   .

  eq statementToMachineSchema((start state SId B) Ss, (machine: MId, start: noid, states: States, initState: Rho))
   = statementToMachineSchema((      state SId B) Ss, (machine: MId, start: SId,  states: States, initState: Rho))
   .

  eq statementToMachineSchema((state SId { entry B }) Ss, (machine: MId, start: StartId*, states: States, initState: Rho))
   = statementToMachineSchema(                        Ss, (machine: MId, start: StartId*, states: ((state: SId, entry: B) States), initState: Rho))
   .

  eq statementToMachineSchema(.Stmt, Schema) = Schema .


 --- Machine Instances
 ---------------------

  sort MachineInstance MachineInstances .
  subsort MachineInstance < MachineInstances .
  op .MachineInstances : -> MachineInstances .
  op _ _ : MachineInstances MachineInstances -> MachineInstances [prec 65 assoc comm id: .MachineInstances] .

 --- arguments: Reference | Code | StateCell
  op (( instance: _ , pgm: _ , state: _ )) : Int Stmt VariableMap -> MachineInstance [prec 63] .

  var Machine  : MachineInstance .
  var Machines : MachineInstances .

  op (( instances: _ )) : MachineInstances -> Attribute [prec 64 format (ncu o++in o n--icu p)] .

 --- Statements
 --------------

 --- Blocks
  eq ( instance: N , pgm: { Ss } , state: Rho )
   = ( instance: N , pgm:   Ss   , state: Rho )
   .

 --- Assignment
  eq ( instance: M , pgm: X = V ; Ss , state: (X |-> V2 Rho) )
   = ( instance: M , pgm:         Ss , state: (X |-> V  Rho) )
   .

 --- new
  eq (instances: ( instance: M , pgm: X = new MId(Exps); Ss , state: Rho )                             Machines ) ( counter: N )
   = (instances: ( instance: M , pgm: X = N ;            Ss , state: Rho ) (new: MId, N +Int 1, Exps)  Machines ) ( counter: N +Int 2 )
   .

 --- arguments: MachineId, Identifier, Arguments
  op ((new: _, _, _)) : Id Nat Exps -> MachineInstance .
  eq (instances: (new: MId, N, Exps) Machines )
     (machines:  (machine: MId, start: StartId, states: ((state: StartId, entry: Ss) States), initState: Rho) ;; Schemas )
   = (instances: (instance: N , pgm: Ss, state: Rho) Machines )
     (machines:  (machine: MId, start: StartId, states: ((state: StartId, entry: Ss) States), initState: Rho) ;; Schemas )
   .

  --- Other infrastructure
  ------------------------

  --- Maps
  sort VariableMap .
  op .VariableMap : -> VariableMap .
  op _|->_ : Id Exp -> VariableMap [prec 60 format (n++i r o --i) ] .
  op _ _ : VariableMap VariableMap -> VariableMap [prec 62 assoc comm id: .VariableMap] .


  var X Y Id MId SId : Id .
  var N M : Nat .
  var V V1 V2 : Int .
  var StartId* : [Id] .
  var StartId  :  Id .
  var T : Type .
  var B : Block .
  var Ss S1s S2s : Stmt .
  var Rho : VariableMap .
  var C : Attributes .
  var Exps : Exps .
  var States : States .


endm

